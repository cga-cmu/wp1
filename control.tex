% SIGN ISSUE ON FORCE FEEDBACK o and w: sort it out

\documentclass[letterpaper,12pt,fullpage]{article}

\usepackage[left=1in,right=1in,top=1in,bottom=1in]{geometry}
\usepackage{cite}
\usepackage{graphicx}
% \usepackage[dvips]{graphicx}
% \usepackage{epsfig} % for postscript graphics files
  % \graphicspath{{../eps/}}
% \DeclareGraphicsExtensions{.eps}
\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage[cmex10]{amsmath}
%\usepackage{array}
%\usepackage{mdwmath}
%\usepackage{mdwtab}
%\usepackage{eqparbox}
\usepackage[tight,footnotesize]{subfigure}
%\usepackage[caption=false]{caption}
%\usepackage[font=footnotesize]{subfig}
%\usepackage{fixltx2e}
%\usepackage{stfloats}
\usepackage{hyperref}

% correct bad hyphenation here
%\hyphenation{op-tical net-works semi-conduc-tor}

\input latex-commands

\newcommand{\gc}{{\mbox {GravityCompensation}}}
\newcommand{\invdyn}{{\mbox {\tiny ID}}}
\newcommand{\invdynw}{{\mbox {\tiny ID+Fw}}}

\newcommand{\shrinkfig}{\def\baselinestretch{1.0}\small} % 0.9 okay
\newcommand{\shrink}{\def\baselinestretch{1.1}\small} % 0.97 % 0.95 okay

\begin{document}

\title{A Survey of Possible Exoskeleton Control Architectures and
Algorithms\\
(Draft 2.3)}

\author{Alex Ansari, Christopher G. Atkeson, Howie Choset, and Matthew Travers\\
Carnegie Mellon University}

\maketitle

\begin{abstract}
Abstract to be written.
\end{abstract}

\section{Executive Summary}

Executive Summary to be written.

\section{Scope: What is this paper about?}

This paper surveys possible exoskeleton control architectures and
algorithms.
One goal is to address the question:
{\it How do exoskeleton control approaches compare with 
approaches to humanoid robot control?}
A companion paper surveys implemented exoskeleton control architectures
and algorithms [survey.pdf].

The focus is on exoskeleton control that allows a
highly trained and top percentile athletic 
operator to carry a payload that weighs approximately the same amount
as the operator. We envisage these types of exoskeletons to be useful
in carrying protective and safety equipment for SWAT teams, police,
firefighters, and soldiers. 

We expect each exoskeleton controller
to be used by and optimized for a single operator.
A substantial investment in capturing the operators normal behavior,
operator training and learning, and controller customization can be made.

We focus this survey on exoskeleton control for lower body tasks (standing, walking,
running, jumping, kicking, dodging, ...).
We do not survey exoskeleton control for human arms or manipulation. 

We treat the torso and helmet of the exoskeleton as the payload,
and focus on a lower body exoskeleton to support any payloads that
are on the torso or head.

%\section{Symbiosis and Autonomy, Handling Errors, and Superhuman Reflexes}
A later white paper will discuss
possible combinations of response to user and exoskeleton
autonomy including balance control; response to trips, slips,
stumbles, and fumbles; task assistance and guidance (guide operator to
doorknob, button, or light switch); superhuman response to external
perturbations such as projectiles and explosions; and autonomous
execution (operator/exoskeleton symbiosis with multi-tasking)?

A later white paper will discuss how to handle malfunctions and damage to the
system. Basically this boils down to fault detection, and switchover to
an appropriate safe mode of operation.

A later white paper will evaluate using simulation
the various control approaches' robustness to modeling error and unmodeled
dynamics.

\subsection{Let's keep it simple}

Terms like impedance and admittance control are used, but are often confusing,
as in controller design one can choose from several possible
inputs into the exoskeleton (exoskeleton positions,
velocities, accelerations, operator-exoskeleton contact forces and
exoskeleton-world contact forces), and choose from several possible exoskeleton
outputs: exoskeleton actuator forces and torques, exoskeleton
motion (position, velocity, and acceleration), as well as operator-exo
contact forces or exo-world contact forces.

A useful background paper on impedance and admittance:\\
\url{http://summerschool.stiff-project.org/fileadmin/pdf/1804_C19.pdf}

Variants of nonlinear feedback control such as feedback linearization or
sliding mode control are largely ignored in this paper.
Once the decision to use feedback control
based on a set of observable quantities and with particular outputs is made,
one can try out the various linear and nonlinear feedback control paradigms
to see what works well.

Variants of function approximation methods such as lookup tables, fuzzy logic,
sigmoidal neural networks, radial basis functions, and locally weighted regression
are also largely ignored. Once the decision to use a function approximator
and what the inputs and outputs are has been made, one can try out the various
approaches to see what works well.

Same for optimization methods.

Same for constraint enforcement (such as avoiding self-collisions)
in either optimization or feedback control (barrier
Lyapunov functions (BLF)~\cite{IEEE06911561}).

Stability proofs of any of these methods should be viewed skeptically due
to the unmodeled operator-exoskeleton and exoskeleton-world contact dynamics, 
actuator unmodeled dynamics, joint play and exoskeleton
structural deformation, and controller
time delays which are typically ignored, especially in proofs involving
passivity arguments or Lyapunov functions.
We ignore stability proofs as well.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{design-goals.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Effects of underlying exoskeleton actuator technology}

One basic distinction is whether the actuators are thought of as position
or force sources. Often this is revealed by the design of the ``low level''
controller. Note that this is often somewhat confusing. Electric motors
are torque sources (low impedance), but when a high gear ratio transmission
is added (such as a harmonic drive) the whole system becomes high impedance
and thus is best thought of as a position (or velocity) source. Therefore,
position or velocity 
control is performed by the low level controller. Hydraulic actuators
are high impedance, but when a force or load sensor is added (or piston differential
oil pressure is used as a force sensor), the whole system becomes low impedance
and is best thought of as a force source. Force (or joint torque) control is
performed by the low level controller. Force or torque sensing can be added to an
electromechanical drive train (electric motor plus gears or electric
motor plus ballscrew)
to make it lower impedance and more like a force source as well.

\section{Recommended Control Architecture}
\label{sec:architecture}

We recommend the following hierarchical control architecture~\cite{IEEE06907051}:

\subsection{Low Level Control (LLC)}

Low level control presents an API (Application Programmer Interface)
for higher control levels
to access the actuators, sensors, and other robot hardware.
It implements high servo rate processing including feedback control and online
optimization.
This level provides an idealization of the exoskeleton in two ways: 
What degrees of freedom (DOF) are controlled, and how is a degree of
freedom controlled?

\subsubsection{LLC: What degrees of freedom are controlled?}

The low level control API may directly map on to the exoskeleton hardware
(physical joints,
raw actuators, and raw sensors), or
it may present an ``abstracted'' view or ``virtual'' hardware.
For example, it is often useful to create virtual degrees of freedom that are
actually combinations of joints, or to control points on the robot in Cartesian
or other coordinates. We refer to these virtual degrees of freedom as {\bf synergies.}
A complex synergy is the center of mass. Higher level control is made easier by
providing a virtual sensor that measures center of mass location and velocity,
as well as providing a virtual actuator that acts at the center of mass in
a Cartesian fashion (push horizontally and vertically in world coordinates).
On a smaller scale, it may simplify higher level control 
to create virtual actuators that cross
multiple joints. These multi-joint actuators are actually implemented by commands
to individual physical single-joint actuators.

\subsubsection{LLC: How is a degree of freedom controlled?}

It is useful to provide human programmers
with idealized abstractions of control of a single degree of
freedom. Here are some common alternatives that could be provided by low level control:
\begin{itemize}
\item
Position control. The joint moves to a specified position and stays there independent
of load.
\item
Velocity control. The joint moves at a specified velocity independent of load.
\item
Force or torque control. The joint provides a specified force or torque independent
of its motion.
\item
Impedance control: The user specifies a desired position (for a spring), and commands
a desired
stiffness, damping, and potentially a modified inertia or moment of inertia.
Modifying inertia is more dangerous than providing variable active stiffness
or damping.
Or (almost equivalently),
the user specifies a desired force or torque
which changes according to the position, velocity,
and acceleration of the joint.
\item
Online optimization of accelerations, actuator forces and torques, and contact forces
using quadratic programming. See Section \ref{sec:qp} for further explanation.
\end{itemize} 

\subsubsection{LLC: Feedback control}

PID or more complex feedback control laws are implemented by low level control.

\subsubsection{LLC: Feedforward control}

Gravity, friction, actuator dynamics, and other feedforward disturbance
compensation are implemented by low level control, as well as any inverse dynamics
or other types of feedforward reference tracking control.

\subsubsection{LLC: Existing examples}

Typically low level control is implemented
by a high sampling rate global servo~\cite{Atlas-robot}
or distributed limb or joint-level high sampling rate servos~\cite{Sarcos-robot}.
Often, this controller is provided by the manufacturer of the robot
or exoskeleton and runs on a separate computer system from the
``user's'' or task/application controller~\cite{Sarcos,Atlas}.

\subsection{``Phoneme'' Control}

This level often provides the behavioral primitives or ``verbs'' for robot programming:
providing mid-level controllers
for relatively constant phases of behavior.
These behaviors often involves position or velocity targets (goto or
stay-at X), and trajectory references.
Example phoneme behaviors from walking: left-stance, double-support-1, right-stance, double-support-2, ....
Example behaviors from running: left-foot-down, flight-1, right-foot-down, flight-2, ....
Example behaviors from horizontal jumping: hjump-pushoff, hjump-flight, hjump-prepare-landing, hjump-impact, hjump-balance, ....
Finer or multiple behavioral resolutions may be needed.
For example a walking stance period may
be broken up into heel-strike, first-half, second-half, pushoff, and toe-off.
The first and second halves of stance are divided by when the center of mass
passes over the ankle.
Local inverse kinematics (finding small joint motions for small target changes)
is performed at this level.

\subsection{``Word'' Control}

This level determines the control flow of a behavior: what happens next?
Mid-level controllers are provided for sequences of ``phoneme'' behavioral
units.
This level often involves finite state machines, timers, if-then condition testing,
and gain or behavior
scheduling.
Example word behaviors: walk-to-location(x=7.8m, y=2.3m), run-to-location(speed=3.7m/s),
and horizontal-jump(height=2m, length=5m).
Global inverse kinematics (selection of solution branch) is performed at this level.

\subsection{Behavior Selection}

The highest level of control in the recommended architecture is behavior selection,
which answers the question:
``What should I do next?''
This level selects behaviors and behavioral parameters (targets,
speeds, durations, etc.).
This level often also 
includes decision tables, finite state machines. timers, if-then condition testing, ...
This level often involves a great deal of human operator online interaction,
or is completely done by the operator.

\subsection{State Estimation}

In this architecture, state estimation to deal with sensor noise,
disturbance estimation, and incomplete or
redundant sensing is a separate process and is as independent as possible
from the control method~\cite{certainty-eq,separation-prin}.
This makes evaluating different control methods much easier.
Disturbance observers for disturbances such as
moving support surfaces, contact or wind forces, and model errors
are also implemented.

\subsection{Error Handling}

Errors must be detected and handled by parameter (target)
adjustment and/or behavior switching
at all of these levels.

\subsection{Why do we recommend this architecture?}

The recommended control architecture is intuitive, abstracts the hardware 
and lower level control in a straightforward way, is easy to program, and is
commonly used. Variants of this architecture were used by almost all teams
in the DARPA Robotics Challenge~\cite{}.

\subsection{What are the alternatives?}

Closely related control architectures combine Phoneme and Word control,
or combine Phoneme, Word, and Behavior Selection.
Neither of these is a major change.

An alternative behavioral architecture might not have explicit levels but instead
has a ``soup'' of behaviors that compete or cooperate for the ability to
control the robot or exoskeleton. Subsumption architecture and other behavior-based
architectures are closer to the ``soup'' approach and to some extent
use inhibition and excitation
among behaviors to select active behaviors.

Another alternative behavioral architecture does not have explicit separate behaviors,
but one or a small number of functions or policies. 
We are seeing more of these architectures
due to the success and popularity of function approximation such as
deep learning.

An alternative approach to state estimation is to design state estimation
and control laws simultaneously~\cite{LQG-LTR}. Another alternative is
to have a controller with internal state, and design or learn a policy
that works well, but does not have an explicit state estimation 
part~\cite{lead-lag}.

\section{Exoskeleton dynamics}

Exoskeletons are similar to robots, but there are several important differences.
There are two sets of contact forces: operator-exoskeleton (which we denote
with a subscript $o$ as in $\vf_o$) and exoskeleton-world (which we denote
with a subscript $w$ as in $\vf_w$). If the operator is tightly strapped or
rigidly held by other types of physical constraints, we can lump the operator
body parts with the exoskelton parts which they are attached to in terms
of link inertias, locations of center of mass, and moments of inertia,
and just think of the whole system as one robot.
We can also separate out the operator dynamics if this is more convenient
(we separate them out and ignore them in what follows).
If the operator is loosely connected to the exoskeleton, this introduces a
huge modeling and control problem, and would also be very dangerous for the
operator (as riding a bull or bucking horse in a rodeo is dangerous to a rider).
We do not address the loosely connected case in this paper.

The dynamics of a revolute exoskeleton standing on the ground are:
\begin{equation}
\mM(\vq) \ddot{\vq} + \mC(\vq,\dot{\vq}) + \mG(\vq) + \mF(\vq,\dot{\vq})
+ \mJ_w^{\tr}(\vq) \vf_w = \vtau + \mJ_o^{\tr}(\vq) \vf_o
\label{eq:dynamics}
\end{equation}
where $\vq$ are the joint angles of
the exoskeleton, $\dot{\vq}$ and $\ddot{\vq}$ are the corresponding
velocities and accelerations, $\mM$ is the inertia matrix, $\mC()$ are the Coriolis and
centripetal forces, $\mG()$ are the gravitational forces, $\mF()$ are the
friction forces, $\mJ_w^{\tr}(\vq) \vf_w$ (Jacobian matrix multiplied with the
contact forces)
are the exoskeleton-world
contact forces 
expressed as exoskeleton joint torques, 
$\vtau$ are the exoskeleton
joint torques,
and $\mJ_o^{\tr}(\vq) \vf_o$
are the operator-exoskelton forces expressed
as exoskeleton joint torques.

We do not describe how to derive this equation or identify appropriate parameters
for an exoskeleton. We can provide this information if requested.
We are assuming that the equations have been derived taking into account constraints
such as one or two feet on the ground. Until we discuss ``floating body'' dynamics
in Section~\ref{sec:float}, we are assuming contacts do not slip and are not broken.
We are assuming all degrees of freedom (joints) are actuated until 
Section~\ref{sec:float}.

To understand these equations better, it is useful to have all Jacobians equal
to the identity matrix. This means the operator is directly applying torques
at the exoskeleton joints ($\vtau_o$) (a realistic assumption), 
and so is the world ($\vtau_w$) (a very unrealistic assumption). In this case:
\begin{equation}
\mM(\vq) \ddot{\vq} + \mC(\vq,\dot{\vq}) + \mG(\vq) + \mF(\vq,\dot{\vq})
+ \vtau_w = \vtau + \vtau_o
\end{equation}

Note that we are ignoring the human operator dynamics and operator muscle and tissue
forces resulting in operator joint torques. Intent prediction will model these
effects [intent.pdf].

We are also ignoring actuator dynamics, which we can handle by augmenting 
the state vector and adding additional equations.

\section{Passive control with no active control}

One control option is to use only passive controls, and no active controls
or actuators.
Such a system would rely on counterbalancing, mechanical springs, air springs, etc.
to reduce forces. 
An operator would rely on mechanical backdrivability to drive
exokeleton to do tasks.
In this case, 
$\vtau$ is generated by passive devices such as springs or dampers.

\section{Open loop control}

Another control option is open loop control, in which actuator commands are
constant, or a function of time or phase of a behavior or task
(at least on the small time scale).
Commands or behaviors may be selected at a relatively coarse time interval
by the operator or by the exoskeleton controller.
This approach typically 
uses position and velocity control in either joint or
Cartesian coordinates
with either pre-generated references, selected targets,
or online generated trajectories to move to targets or perform tasks.
The operator relies on mechanical backdrivability 
to correct exoskeleton behavior.
In this case, it is common to generate the exoskeleton actuator commands using
a time or phase index:
$\vtau = \vtau_{ff}(t)$ where $\vtau_{ff}$ is a time
dependent feedforward torque vector.

\section{Active gravity compensation}

Active gravity compensation is similar 
to counterbalancing or physical gravity compensation, except it is done
with exoskeleton actuators to cancel the exoskeleton weight (but not inertia).
\begin{equation}
\vtau = \hat{\mG}(\hat{\vq})
\end{equation}
where $\vtau$ are the exoskeleton joint torques, 
$\hat{\mG}()$ are the gravitational forces calculated using an imperfect model, 
and $\hat{\vq}$ is the estimated configuration of the exoskeleton,
The operator relies on mechanical backdrivability to drive
the exokeleton to do tasks.

Sarcos Primus Humanoid videos of active gravity compensation applied
to a humanoid robot:\\
CMU: cancel gravity and friction: \url{https://www.youtube.com/watch?v=Ac5cowTwOPw}\\
ATR: cancel gravity only: \url{https://www.youtube.com/watch?v=KNxxLm4sPys}

A simple approximation for a lower body exoskeleton with a heavy payload at the
torso is:
\begin{equation}
\vtau \approx \hat{\mJ}^{\tr}(\hat{\vq}) (\hat{m} \hat{\vg})
\end{equation}
where $\hat{\mJ}$ is the estimated Jacobian matrix,
$\hat{m}$ is the estimated
weight of the exoskeleton (which could include the operator),
and $\hat{\vg}$ is the gravity vector (it is estimated due to possible orientation
errors in the controller's estimate of vertical).
All weight is assumed to be concentrated at the center of mass of the full system.

\section{Friction compensation}

Friction can also be compensated.
\begin{equation}
\vtau = \hat{\mF}(\hat{\vq},\hat{\dot{\vq}}) 
\end{equation}
are the estimated friction torques at the estimated exoskeleton configuration
and velocity.
Note that these may be load dependent, and may require additional state to
correctly handle stiction and hysteresis effects.

Sarcos Primus Humanoid video of friction compensation applied
to a humanoid robot:\\
CMU: cancel gravity and friction: \url{https://www.youtube.com/watch?v=Ac5cowTwOPw}\\

\section{Online inverse dynamics control}
\label{sec:invdyn}

The goal here is to map from desired motion (in this case desired
accelerations) to exoskeleton actuator commands (and desired operator
and world contact forces).
The exoskeleton actuator torques
attempt to match the torques caused by inertial, Coriolis, centripetal,
gravitational, and frictional forces.
\begin{equation}
\vtau = \vtau_{\invdyn} 
= \hat{\mM}(\hat{\vq}) \ddot{\vq}_d
+ \hat{\mC}(\hat{\vq},\hat{\dot{\vq}})
+ \hat{\mG}(\hat{\vq})
+ \hat{\mF}(\hat{\vq},\hat{\dot{\vq}})
\end{equation}
If in addition we want to cancel exoskeleton-world contact forces,
we add another term:
\begin{equation}
\vtau = \vtau_{\invdynw} = \vtau_{\invdyn} 
+ \hat{\mJ}_w^{\tr}(\hat{\vq}) \hat{\vf}_w
\end{equation}
If there are actuator dynamics or other dynamics, we can include those
dynamics as well.

These force/torque estimates rely on estimated dynamic models and their parameters.
If the models and estimated state (position and velocity) are perfect, we get
perfect cancellation of most of the dynamics:
\begin{equation}
\mM(\vq) (\ddot{\vq} - \ddot{\vq}_d) = \mJ_o^{\tr}(\vq) \vf_o
\end{equation}
If $\ddot{\vq}_d$ is set to zero, the operator directly drives the acceleration
of the exoskeleton with an effective inertia of $(\mM^{-1}(\vq) \mJ_o^{\tr}(\vq))^{-1}$
\begin{equation}
\ddot{\vq} = \mM^{-1}(\vq) \mJ_o^{\tr}(\vq) \vf_o
\label{eq:cancel}
\end{equation}
$\ddot{\vq}_d$ can be used to drive the exoskeleton along trajectories, and
the operator can directly modify the trajectory.

Simplifying equation~\ref{eq:cancel} by 
assuming the operator directly applies torques at the
exoskeleton joints we get:
\begin{equation}
\mM (\vq) \ddot{\vq} = \vtau_o
\end{equation}
The operator sees the true inertia of the exoskeleton, but no gravitational
loads and no other dynamics (Coriolis, centripetal, or frictional).

Note that we cannot change the apparent inertia of the exoskeleton without
some form of acceleration or force feedback.
With acceleration feedback we can make the exoskeleton have a different inertia.
Setting $\ddot{\vq}_d$ to zero and adding acceleration feedback:
\begin{equation}
\vtau = \vtau_{\invdynw} - (\mM_d(\hat{\vq}) - \hat{\mM}(\hat{\vq})) \hat{\ddot{\vq}}
\label{eq:change-inertia1}
\end{equation}
sets the apparent inertia to $\mM_d$ if the dynamic models are perfect, and
state estimation produces not only perfect positions and velocities but
also perfect acceleration estimates. In the case 
where the operator directly applies torques at the
exoskeleton joints we get:
\begin{equation}
\mM_d (\vq) \ddot{\vq} = \vtau_o
\end{equation}
In robotics this is usually considered a bad idea if $\mM_d$ is smaller (a complex
issue for a matrix) than $\mM$ at any $\vq$. This type of control is vulnerable
to unmodeled dynamics. However, in an exoskeleton, since we have not tried to
cancel the human's dynamics, the human stabilizes a possible unstable exoskeleton
(if the straps are tight enough).

With force feedback we can also make the exoskeleton have a different inertia.
Setting $\ddot{\vq}_d$ to zero and adding force feedback:
\begin{equation}
\vtau = \vtau_{\invdynw} + \mK \hat{\vf}_o
\end{equation}
In the case where the force measurements are perfect and 
the operator directly applies torques at the
exoskeleton joints we get:
\begin{equation}
(\mK + \mI)^{-1} \mM (\vq) \ddot{\vq} = \vtau_o
\end{equation}
By setting $\mK = \mM^{-1}_d (\vq) \mM (\vq) - \mI$ we can achieve
\begin{equation}
\mM_d (\vq) \ddot{\vq} = \vtau_o
\end{equation}

Online inverse dynamics control is a generalization of 
active gravity compensation to include
inertial, Coriolis, and centripetal forces (forces due to acceleration and
velocity), and potentially frictional forces.
Online inverse dynamics can be added to open loop behavior execution
and many other types of control such as operator force
feedback control, impedance control, and admittance control.
Computed torque control and feedback linearization are forms of online
inverse dynamics.

A key question is where does the desired acceleration $\ddot{\vq}_d$ come from?
This is discussed in the companion paper [intent.pdf].

\section{Operator-Exoskeleton Impedance Control}

What is impedance?
\url{https://en.wikipedia.org/wiki/Mechanical_impedance}
Stiffness, damping, and mass are components of an impedance, as
they map kinematic variables (position, velocity, and acceleration)
to forces and torques.

The goal here is to make the exoskeleton imitate a desired linear dynamic system
from the point of view of the operator.
Section~\ref{sec:impw} discusses how to make the exoskeleton 
imitate a desired linear dynamic system 
from the point of view of external perturbations.
In the case where there is no force sensing between the operator and the
exoskeleton, the exoskeleton controller maps from exoskeleton configuration
and velocity to desired joint/actuator/synergy forces.
In this case the actuators need to generate forces and torques rather than
positions or angles, or linear or angular velocities.

Here we make the exoskeleton appear as a locally linear impedance in joint
coordinates to the operator.
We can also make the exoskeleton appear as a locally linear impedance to the
operator in some other coordinate system, such as Cartesian coordinates.
A different goal is to make the exoskeleton appear as a locally linear impedance to
the outside world in some coordinate system.

To make the exoskeleton appear as a locally linear impedance in joint
coordinates to the operator, we add position and velocity feedback to $\vtau$:
\begin{equation}
\vtau = \vtau_{\invdynw} - \mK_{\vq} ( \hat{\vq} - \vq_d ) - \mK_{\dot{\vq}} \hat{\dot{\vq}}
\label{eq:impedance}
\end{equation}
so if the dynamic models and state estimation are perfect we get this impedance:
\begin{equation}
\mM \ddot{\vq} - \mK_{\dot{\vq}} \dot{\vq} - \mK_{\vq} ( \vq - \vq_d ) = \vtau_o
\end{equation}
and the operator sees the desired impedance.

{\it Although impedance control is extensively utilized in rehabilitation
robotics [18], only a limited number of studies has been focused on
this method for power augmentation [19, 20].}
\begin{verbatim}
[18] R. Riener, L. Lunenburger, S. Jezernik, M. Anderschitz, G. Colombo,
and V. Dietz, "Patient-cooperative strategies for robot-aided treadmill
training: first experimental results," Neural Systems and Rehabilitation
Engineering, IEEE Transactions on, vol. 13, pp. 380-394, 2005.
[19] B.-K. Lee, H.-D. Lee, J.-y. Lee, K. Shin, J.-S. Han, and C.-S. Han,
"Development of dynamic model-based controller for upper limb
exoskeleton robot," in Robotics and Automation (ICRA), 2012 IEEE
International Conference on, 2012, pp. 3173-3178.
[20] W. Yu, J. Rosen, and X. Li, "PID admittance control for an upper limb
exoskeleton," in American Control Conference (ACC), 2011, 2011, pp.
1124-1129.
\end{verbatim}

\section{Force feedback and get out of the way control (inverse dynamics version)}

The goal here is to use force sensing between the operator and the
exoskeleton to ultimately generate exoskeleton velocities or angular velocities,
imitating a desired linear dynamic system.
This type of control is often referred to as admittance control as the
exoskeleton maps contact forces into joint motion.
Inverse dynamics control
can be used to improve this type of control performance.

What is admittance?
\url{https://en.wikipedia.org/wiki/Admittance}
Compliance, inverse damping, inverse mass are components of an admittance,
as they map force and torques to kinematic variables (position, velocity, and
acceleration). 

We can implement operator force control 
if measurements of the operator contact forces with
the exoskeleton are available.
The exoskeleton moves as to create as little force on the operator as possible 
assuming the actuators are torque sources:
\begin{equation}
\vtau = \vtau_{\invdynw} + \mJ_o^{\tr}(\vq) {\vf_o}_d
+ \mJ_o^{\tr}(\vq) \mK_{\vf_o} ( \hat{\vf}_o - {\vf_o}_d )
\end{equation}
$\mK_{\vf_o}$ is a gain matrix, $\mJ_o$ is the Jacobian matrix for the operator
force $\vf_o$
Note that this does not require inverting the Jacobian matrix.
We will see that the position control version does invert the Jacobian matrix.

Applying this to force between the operator and the exoskeleton, and assuming
that the operator directly applies exoskeleton joint torques,
\begin{equation}
\vtau = \vtau_{\invdynw} + {\vtau_o}_d - \mK_{\vtau_o} ( \hat{\vtau}_o - {\vtau_o}_d )
\end{equation}
So if our dynamic models and state estimation are perfect, we get:
\begin{equation}
\ddot{\vq} = - \mM^{-1} (\vq) ({\vtau_o}_d + \mK_{\vtau_o} ( \hat{\vtau}_o - {\vtau_o}_d ))
\end{equation}

One can add force damping terms, which sometimes help:
\begin{equation}
\vtau = \vtau_{\invdynw} + {\vtau_o}_d - \mK_{\vtau_o} ( \hat{\vtau}_o - {\vtau_o}_d )
- \mK_{\dot{\vtau}_o} \hat{\dot{\vtau}}_o
\end{equation}

Note that impedance control can also be implemented using force control
by setting:
\begin{equation}
{\vtau_o}_d = \mK_{\vq}( \hat{\vq} - \vq_d ) + \mK_{\dot{\vq}} \hat{\dot{\vq}}
\end{equation}
in addition to directly including the stiffness and damping terms in
equation~\ref{eq:impedance}. 

\section{Mapping External Forces To Operator Forces Using Force Control}

So far we have ignored or canceled the effect of 
the exoskeleton contact with the outside world.
A different control objective could be to map the external forces to 
desired operator forces:
\begin{equation}
{\vf_o}_d = F_{ow} ( \vf_w )
\end{equation}
and cancel the external forces not transferred in the inverse dynamics.
Everything in the above equation is estimated, so we are dropping the hats 
$\hat{\mbox{}}$.

For example, we could want the operator to feel a scaled (scale factor $\alpha$) 
version of the external
forces, as if they were contacting the operator directly.
\begin{equation}
{\vf_o}_d = \alpha J_o^{-\tr}(\vq) J_w^{\tr}(\vq) \vf_w
\end{equation}
and we scale the $\mJ_w^{\tr}(\vq) \vf_w$ term in the inverse dynamics
by $(1-\alpha)$
We are assuming we have any necessary force sensing between the exoskeleton and
the world.

If the operator applies joint torques, this simplifies to
\begin{equation}
{\vtau_o}_d = \alpha J_w^{\tr}(\vq) ( \vf_w )
\end{equation}
and the inversion of a Jacobian matrix is unnecessary.

This would provide a way of enabling the operator to perceive and control
external contact forces.

\section{Autonomous exoskeleton control}

\subsection{Autonomous exoskeleton position/velocity control}

A control objective could be to have the exoskeleton to move autonomously,
which is useful if the operator would like to rest, is attending to some other
task, or is disabled.

This is usually done by using stored trajectories or trajectories generated
online that specify desired position $\vq_d$, 
desired velocity $\dot{\vq}_d$, and
desired acceleration $\ddot{\vq}_d$.
The feedforward method is to compute the needed torques (potentially offline)
using inverse
dynamics (including the operator link inertias, link centers of mass, and link
moments of inertia in the dynamic model) based on the desired postion, 
desired velocity, and desired acceleration. Trajectory tracking errors are compensated
for by feedback control designed using some other method. In most robotics
fixed gain independent joint linear control is used.
This method is safest in the sense that the feedback controller can be tested
and verified independently of the desired trajectories and dynamic models.

Computed torque approaches use online inverse dynamics computed from the estimated
position, estimated velocity, and desired acceleration.
In this case the feedback control to compensate for trajectory tracking errors can
be independent of the inverse dynamics and its modeling errors, or the desired
acceleration can be modified with feedback terms.
\begin{equation}
\ddot{\vq}_d^* = \ddot{\vq}_{d} + \mK_{\vq}^{\ddot{\vq}} ( \hat{\vq} - \vq_d ) 
+ \mK_{\dot{\vq}}^{\ddot{\vq}} ( \hat{\dot{\vq}} - \dot{\vq_d} )
\label{eq:computed-torque-control}
\end{equation}
The problem with putting the inverse dynamics in the feedback loop 
(equation~\ref{eq:computed-torque-control})
is that the
effective gains of this control vary widely with the configuration $\vq$.
Unmodeled dynamics (that also vary with $\vq$) limit the size of the gain matrices
$\mK_{\vq}^{\ddot{\vq}}$ and $\mK_{\dot{\vq}}^{\ddot{\vq}}$. Because so many quantities
are varying quite a bit, constant gain matrices may be quite small for a worst case
design. It is also very difficult to evaluate and 
verify this type of nonlinear feedback controller.
For these reasons most current approaches to humanoid
robots design the feedback controller
separately (and manually) 
and use constant gain independent joint linear feedback control.

\subsection{Autonomous exoskeleton-world force control}

A control objective could be to have the exoskeleton to autonomously
apply a desired force.
One could add
\begin{equation}
\vtau = \vtau_{\invdyn} + \mJ_w^{\tr}(\vq) {\vf_w}_d
\end{equation}
to a gravity compensated control or to control including inverse dynamics.

Active force control could be added to improve the performance:
\begin{equation}
\vtau = \vtau_{\invdyn} + \mJ_w^{\tr}(\vq) {\vf_w}_d + \mJ_w^{\tr}(\vq) \mK_{\vf_w} (\vf_w - {\vf_w}_d)
\end{equation}

\subsection{Autonomous exoskeleton-world impedance control}
\label{sec:impw}

Another control objective would be to allow the exoskeleton-world contact to
be compliant or have an assigned impedance.
Let's describe a small position offset of the exoskeleton-world
contact points as $\vq_w$. We know that:
\begin{equation}
\dot{\vq}_w = \mJ_w(\vq) \dot{\vq}
\end{equation}
and that
\begin{equation}
\vtau = \mJ_w^{\tr}(\vq) \vf_w 
\end{equation}
This allows us to relate stiffness and damping in the external world coordinates
with the stiffness and damping in exoskeleton joint coordinates.
Here is the relationship for damping:
\begin{equation}
\vtau = \mJ_w^{\tr}(\vq) \mK_{\dot{w}} \mJ_w(\vq) \dot{\vq}
\end{equation}
So the damping in joint coordinates is $\vtau = \mK_{\dot{\vq}} \dot{\vq}$ and
therefore
\begin{equation}
\mK_{\dot{\vq}}(\vq) = \mJ_w^{\tr}(\vq) \mK_{\dot{w}} \mJ_w(\vq)
\end{equation}
The mapping is the same for stiffnes:
\begin{equation}
\mK_{\vq}(\vq) = \mJ_w^{\tr}(\vq) \mK_{w} \mJ_w(\vq)
\end{equation}
So we should assign the exoskeleton joint position gains to be $\mK_{\vq}(\vq)$ and
the joint velocity gains to be $\mK_{\dot{\vq}}(\vq)$ in equation~\ref{eq:impedance}.

Similarly, we can use exoskeleton-world force control to improve performance,
setting
\begin{equation}
{\vf_w}_d = - \mK_w ( \hat{\vq}_w - {\vq_w}_d ) - \mK_{\dot{w}} \hat{\dot{\vq}}_w
\end{equation}
and add the force error: 
\begin{equation}
\vtau = \vtau_{\invdyn} - \mK_{\vq} ( \hat{\vq} - \vq_d ) - \mK_{\dot{\vq}} \hat{\dot{\vq}}
+ \mJ_w^{\tr}(\vq) \mK_{\vf_w} ( \hat{\vf}_w - {\vf_w}_d )
\end{equation}

\section{Underactuated and overactuated control and floating body dynamics}
\label{sec:float}

This section describes how to handle underactuation and overactuation using
``floating body dynamics.''
We have been sweeping this
issue under the rug so far. It is now useful to be more explicit.
There are two kinds of underactuation we want to consider. The first
is ``floating body dynamics'', where the robot is not bolted to the floor.
Humanoid robots (and humans) have floating body dynamics.
A ``root'' location (usually somewhere
on the pelvis) is chosen, and the position, velocity, orientation, and angular
velocity of that point and the rigid body it is on
are included in the state vector $\vq$. The corresponding dimensions of the
velocity vector $\dot{\vq}$ are not actuated. A selection matrix
$\mS$ is used to map from actuation variables $\vu$ to joint torques $\vtau$:
\begin{equation}
\vtau = \mS \vu
\end{equation}
The rows in $\mS$ corresponding to the root linear and angular velocities
are all zero.

The second kind of underactuation appears in exoskeletons where we rely on the
operator to actuate a particular joint. For example, many lower body
exoskeltons only actuate the joints in the sagittal plane, leaving lateral
and twist (yaw) joints unactuated or passively actuated. 

Passive actuation can be handled by augmenting the
dynamics equations to include the force equation of the passive element,
such as a nonlinear spring.

The underactuation can be handled by reducing the size of the $\vu$ vector
and changing the matrix $\mS$ to reflect the missing actuation.
We can have redundant actuation (more than one actuator across any particular
joint). Here we augment $\vu$ and $\mS$ to accomodate extra actuators.
We can have multijoint actuation, which can be handled in $\vu$ and $\mS$ as well.

The modified dynamics equations are
\begin{equation}
\mM(\vq) \ddot{\vq} + \mC(\vq,\dot{\vq}) + \mG(\vq) + \mF(\vq,\dot{\vq})
+ \mJ_w^{\tr}(\vq) \vf_w = \mS \vu + \mJ_o^{\tr}(\vq) \vf_o
\label{eq:dynamics2}
\end{equation}
Note that $\ddot{\vq}$ and the new actuation vector $\vu$
do not have the same dimensionality. What difference does that make?

Underactuated joints reduce our ability to control behaviors directly
through the actuators. In some cases we can control unactuated degrees of freedom
through indirect effects over time, and in some cases those degrees of freedom
are not ``controllable'' in the technical sense. Remember that we have a human
operator that fully actuates the exoskeleton, so having some degrees of freedom
that are not controllable by the actuators is not fatal to a design.

The {\bf no control} case is unchanged with underactuation.

{\bf Open loop control} continues to work with underactuation
as long as a drive function can be found
to generate the desired behavior.

{\bf Gravity compensation} and {\bf friction compensation}
still work on the actuated degrees
of freedom. Passive actuation or 
the operator needs to carry the load on the unactuated degrees of freedom.

Straightforward {\bf online inverse dynanamics} as described in Section~\ref{sec:invdyn}
no longer works if $\mS$ is not invertable (not square or not full rank).
In the underactuated and overactuated cases $\mS$ is not square. 
In these cases {\bf online optimization}
as described in the next Section is used to ``perform inverse dynamics'' by
finding desirable combinations of accelerations $\ddot{\vq}$, contact forces $\vf$,
and actuator commands $\vu$.

Another approach to solving this problem is prioritized control, which does
not include optimization~\cite{}. For reasons we will describe, we believe
online optimization is much more flexible and can handle programming exoskeleton
behavior much better, so we will not discuss prioritized control further.

\section{Using Online Optimization: Quadratic Programming}
\label{sec:qp}

The dominant paradigm in force controlled (typically
hydraulic) full size humanoid robots is to use online optimization
to handle under and overactuation
and to handle constraints in inverse dynamics
such as torque and center of pressure limits.
Online optimization typically solves the constrained inverse dynamics problem
using quadratic programming.
This approach is used
to implement and trade off among the many control objectives described so far.

Quadratic programming~\cite{Wikipedia} solves the following problem:
Minimize
\begin{equation}
\vx^{\tr} \mQ \vx + c^{\tr} \vx
\end{equation}
with inequality constraints
\begin{equation}
\mA_1 \vx \le \vb_1
\end{equation}
and equality constraints
\begin{equation}
\mA_2 \vx = \vb_2
\end{equation}
The optimization variable $\vx$ includes accelerations $\ddot{\vq}$, actuator
commands $\vu$, and contact forces $\vf$.
For robots the discrepancy between actual and desired accelerations, actuator command
magnitude, and contact force magnitude are all minimized:
\begin{equation}
C_r(\vx) = (\vq - \vq_d)^{\tr} \mW_{\vq} (\vq - \vq_d) + \vtau^{\tr} \mW_{\vtau} \vtau
+ \vf^{\tr} \mW_{\vf} \vf
\end{equation}
$\mW_{\vq}$, $\mW_{\vtau}$, and $\mW_{\vf}$ are weight matrices to trade off the
different errors/magnitudes and error/magnitude directions.
The dynamics (equation~\ref{eq:dynamics2}) are enforced as an equality constraint.
Actuator limits, friction limits, center of pressure location constraints,
and unidirectional contact constraints are all
enforced as inequality constraints.
Variants of this optimization
were performed every 1-2ms by various teams to control the
Atlas robots in the DARPA Robotics Challenge.

This approach can be used to achieve desired joint or synergy (such as center
of mass) accelerations, center of mass dynamic behavior, center of pressure location,
weight distribution, maintenance of a desired body part position, orientation,
velocity, or trajectory. and joint/actuator position and velocity limits (indirectly).

\subsection{Controlling operator forces and perceived exoskeleton impedance}

In the case of exoskeletons, 
part of the optimization criterion could be to
minimize contact forces on the operator:
\begin{equation}
C_e(\vx) = C_r(\vx) + \vf^{\tr}_o \mW_{\vf_o} \vf_o
\end{equation}
Operator force feedback and impedance control could be implemented by specifying a
desired operator force ${\vf_o}_d$ and adding a ``hard'' equality constraint:
\begin{equation}
\vf_o = {\vf_o}_d
\end{equation}
or by adding a ``soft'' constraint in the form of a new term in the optimization
criterion:
\begin{equation}
C_e(\vx) = C_r(\vx) + (\vf_o - {\vf_o}_d)^{\tr} \mW_{\vf_o} (\vf_o - {\vf_o}_d)
\end{equation}
Force damping can be implemented by adding the following ``soft'' constraint term
to the optimization criterion:
\begin{equation}
\dot{\vf}_o^{\tr} W_{\dot{\vf}_o} \dot{\vf}_o
\end{equation}

We can implement operator {\bf impedance control} in several ways:
We can add 
the impedance equations as ``hard'' equality constraints (to achieve them exactly)
\begin{equation}
\mJ_o^{\tr} {\vf_o} = \mK_{\vq}( \hat{\vq} - \vq_d ) + \mK_{\dot{\vq}} \hat{\dot{\vq}}
\end{equation}
or by adding the ``soft'' constraint ``equation error'' to the optimization criterion
weighted by a weight factor $W_{imp}$ to indicate
how large an error is tolerated:
\begin{equation}
\ve = \mJ_o^{\tr} {\vf_o} - \mK_{\vq}( \hat{\vq} - \vq_d ) - \mK_{\dot{\vq}} \hat{\dot{\vq}}
\end{equation}
and
\begin{equation}
\ve^{\tr} W_{imp} \ve
\end{equation}

We can alternatively just set the desired operator contact force to:
\begin{equation}
{\vf_o}_d = \mJ_o^{-1} ( \mK_{\vq}( \hat{\vq} - \vq_d ) + \mK_{\dot{\vq}} \hat{\dot{\vq}} )
\end{equation}
Unfortunately, this involves inverting the Jacobian matrix, which may introduce
problems.
Assuming that the operator directly applies exoskeleton joint torques, 
we can get rid of the Jacobian matrix, and this becomes
the equality constraint
\begin{equation}
\vtau_o = \mK_{\vq}( \hat{\vq} - \vq_d ) + \mK_{\dot{\vq}} \hat{\dot{\vq}}
\end{equation}
or is added to the optimization criterion:
\begin{equation}
C_e(\vx) = C_r(\vx) 
+ (\vtau_o - {\vtau_o}_d)^{\tr} \mW_{\vtau_o} (\vtau_o - {\vtau_o}_d)
\end{equation}
with
\begin{equation}
{\vtau_o}_d = \mK_{\vq}( \hat{\vq} - \vq_d ) + \mK_{\dot{\vq}} \hat{\dot{\vq}}
\end{equation}

{\bf Mapping external forces to operator forces} can be done either with the
``hard'' equality constraint:
\begin{equation}
\vf_o = F_{ow} ( \vf_w )
\end{equation}
or using the ``soft'' constraint term:
\begin{equation}
(\vf_o - F_{ow} ( \vf_w ))^\tr \mW_{fmap}  (\vf_o - F_{ow} ( \vf_w ))
\end{equation}

Similar techniques are used to handle {\bf autonomous exoskeleton position, velocity,
force, and impedance control.}

\subsection{How can the operator share control with autonomous control?}

The use of online optimization makes sharing control with an operator easy.
Dimensions (even actuated dimensions) that are under the operator's control have
low weights in the online optimization. It is also easy to map operator controls
such as joysticks, sliders, and alternative interfaces to almost any desired
control outcome by including these measurements in the online optimization.
The operator and the controller can ``share'' or ``blend''
control by making their respective
weight matrices similar.

\subsection{Full Atlas robot implementation.}

Discuss or point to DRC papers by multiple groups.

\section{Operator-Exoskeleton Force Control using position controlled actuation}

We will now consider position controlled actuators.
At this point our dynamics formulation is no longer appropriate, since we
are assuming the actuators are now position rather than torque sources.

\subsection{Get out of the way control with position sources}

The exoskeleton moves as to create as little force as possible between the
operator and the exoskeleton. The actuators in this case may be position sources or
force sources with high servo gains,
but ultimately operator-exoskeleton forces are mapped
to exoskeleton velocities or angular velocities.

\begin{equation}
\dot{\vq}_d = \mJ^{-1} (\mK_1 \vf)
\label{eq:gootwcps}
\end{equation}
where $\dot{\vq}_d$ are the commanded exoskeleton joint velocities,
$\mJ$ is an appropriate Jacobian matrix, $\mK_1$ is a gain matrix,
and $\vf$ is the force vector to be controlled~\cite{IEEE06990981}.

Inverting a Jacobian matrix is problematic when the matrix is
nearly singular.
Using a fixed or gain scheduled gain matrix may make more sense.
\begin{equation}
\dot{\vq}_d = \mK_3 \vf
\end{equation}
Simplifying equation~\ref{eq:gootwcps}
by assuming the forces to be controlled
are directly applied to the exoskeleton joints, and thus the Jacobian matrix
is the identity matrix, gives us a similar equation:
\begin{equation}
\dot{\vq}_d = \mK_1 \vtau_o
\end{equation}
and we avoid inverting a Jacobian and problems with singularities.

\subsection{Operator force feedback with position sources}

We introduce a desired force to allow for more complex force control.
\begin{equation}
\dot{\vq}_d = \mJ^{-1} (\mK_1 (\vf - \vf_d))
\end{equation}

The exoskeleton could move as to provide a scaled version of exoskeleton-world
contact forces, or some other (usually simple) mapping. 
\begin{equation}
\vf_d = \alpha \mJ_{ow} \vf_w
\end{equation}

\section{Specific Proposed and Implmented Exoskeleton Control Schemes}

\subsection{Sensitivity Amplification Control}

Sensitivity Amplification Control (SAC) used to control BLEEX
is a dynamic cancellation technique (a.k.a.
inverse dynamics, computed torque, or feedback linearization) that also tries
to modify the apparent inertia of the exoskeleton (equation~\ref{eq:change-inertia1})
using acceleration feedback. It is not clearly stated but it appears that the
acceleration is the result of double differentiating position, as there do not
appear to be velocity sensors on BLEEX. Low pass filtering is applied to reduce
the high frequency noise amplified by the double differentiation process.

\subsection{Integral admittance control}

{\it [Exoskeletons] have the implicit property
of causing a virtual modification of the dynamic response of
the human limb. We use this property of the exoskeletons
action to formulate a unified control design framework called
Integral Admittance [torque to angle] Shaping, which designs exoskeleton con-
trollers capable of producing the desired dynamic response
for the assisted limb. In this framework, a virtual increase
in the admittance of the limb is produced by coupling it
to an exoskeleton that exhibits active behavior. Specifically,
our framework shapes the magnitude profile of the integral
admittance (i.e. torque-to-angle relationship) of the coupled
human-exoskeleton system, such that the desired assistance is
achieved. This framework also ensures that the coupled stability
and passivity are guaranteed.}~\cite{Nagarajan_etal_2015}

{\it ... the impedance of the coupled human-exoskeleton
system needs to be reduced below that of the unassisted
human limb. This implies that the exoskeleton needs to
cancel its own impedance first and then compensate for
at least a part of the human limb’s impedance. Therefore,
the desired exoskeleton behavior must be that of a negative
impedance ... Consequently,
the feedback gains will all be
positive. In other words, the exoskeleton controller uses
positive feedback, and hence the exoskeleton exhibits active
behavior, which is capable of performing net positive work
on the limb. ...
However, positive feedback naturally raises the question of
stability, and so we now explain how coupled stability can be
achieved. Although the exoskeleton exhibits active behavior,
which can be potentially destabilizing, the controller can be
designed such that the coupled human-exoskeleton system
is stable and passive. ... 
}~\cite{Nagarajan_etal_2015}

{\it
... Inertia compensation is more complex ...
It can be shown that using only positive acceleration
feedback ..., the gain margin of the coupled system
reduces to the moment of inertia of the exoskeleton, which
implies that the exoskeleton controller ... can at the most
compensate for the exoskeleton’s own moment of inertia
before going unstable. This implies that the moment of
inertia of the coupled human-exoskeleton system cannot be
reduced below that of the unassisted human limb, without
compromising coupled stability. However, using low-pass
filtered acceleration feedback, it can be shown that inertia 
reduction can be achieved. ...
This work uses filtered acceleration
feedback with a second-order low-pass Butterworth filter. ...
}~\cite{Nagarajan_etal_2015}

This is a form of frequency domain virtual model control.

\begin{verbatim}
Kalman filter:
P. Canet, “Kalman filter estimation of angular velocity and accelera-
tion: On-line implementation,” McGill University, Montr ́eal, Canada,
Tech. Rep. TR-CIM-94-15, Nov. 1994.
\end{verbatim}

\subsection{Dual Control Appproach}

This approach implements a passive swing leg in addition to Sensitivity 
Amplification Control for the stance leg.

{\it The robot utilized the dual-mode control scheme, which is
comprised of the active control for the stance phase and the
passive control (using bypass valves) for the swing phase, to achieve high walking
speed in the swing phase while supporting heavy loads in
the stance phase. To reduce the sudden change of the torque
command at the transition from the swing phase to the stance
phase, a smoothing method is adopted. We also implemented
a pre-transition method to take a foot off quickly for fast
walking by predicting the change from the swing to the stance
in advance.}~\cite{IEEE07222598}

Bypass valves implement what Sarcos calls ``dangle''.

Stance: virtual joint torque control method Kazerooni et al.(2005)
When contact location between the wearer and the
exoskeleton is not fixed and difficult to estimate, this method
has been shown to be an effective method to generate the
locomotion for an exoskeleton robot.[3],[4],[21]
\begin{verbatim}
H. Kazerooni , Z. Racine , L. Huang and R. Steger ”On the control of
the Berkeley lower extremity exoskeleton (BLEEX),” Proc. IEEE Int.
Conf. Robot. Autom., pp. 4364-4371, 2005.
Racine Jean-Louis Charles ”Control of a Lower Extrmity Exoskeleton
for Human Performance Amplification,” University of California,2003.
582
Xiuxia Yang, Hongchao Zhao, Yi Zhang, Xiaowei Liu ”Carrying
Lower Extreme Exoskeleton Rapid Terminal Sliding-Mode Robust
Control,” Journal of computers, vol.9, No.1,202-208. 2014.
\end{verbatim}

To reduce
sudden changes(command jump) at the phase transitions, a
smoothing method [5],[19] is introduced and a pre-transition
method is used to solve the swing delay due to the internal
pressure(approx 5 bar).
\begin{verbatim}
H. Kazerooni , Ryan Steger, Lihua Huang ”Hybrid Control of the
Berkeley Lower Extremity Exoskeleton (BLEEX),” Int. Journal of
Robotics Research, pp. 561-573, 2006.
oonbum Bae, Kyoungchul Kong, Masayoshi Tomizuka ”Gait Phase-
Based Control for a Rotary Series Elastic Actuator Assisting the knee
\end{verbatim}

Transition Control

1) Smoothing Method: During transitions of the gait
phase, discontinuity of the control command torque are
occurred by the different condition for the fixed coordinate
which is on the backpack at the swing phase or the foot at
the stance phase. In this paper, to reduce this sudden change
due to gait phase changes, a smoothing method is proposed
as shown in Fig. 7. An exponential function is considered
as the weighting function for smoothing as shown in (6).
In this case, the weighting is small at the initial stage but
it exponentially converges to one for supporting the load
quickly.

2) Pre-transition Method: The pre-transition method is
that the passive mode is executed in the pre-swing phase
prior to toe off. This dramatically reduces the moving

\subsection{Ground Reaction Force Control}

{\it
The ground reaction
forces (GRF) magnitude and direction is used to command the
actuators. In some research the GRF sensors are used
together with other sensors in the control architectures [17],
while in other exoskeleton the control system is based on the
GRF merely [RoboKnee, Honda].
}
\begin{verbatim}
17: K. Suzuki, G. Mito, H. Kawamoto, Y. Hasegawa, and Y. Sankai,
"Intention-based walking support for paraplegia patients with Robot
Suit HAL," Advanced Robotics, vol. 21, pp. 1441-1469, 2007
\end{verbatim}

\subsection{Virtual model control}

The goal here is to make the exoskeleton imitate a desired (usually nonlinear)
dynamic system,
For running it could be a pogo stick or trampoline, for example.

There are several possible versions of this type of control:
\begin{enumerate}
\item
Map from operator-exoskeleton contact forces and system state
to exoskeleton actuator or internal forces.
\item
Map from operator-exoskeleton contact forces and system state
to exoskeleton acceleration.
\item
Map from operator-exoskeleton contact forces and system state
to exoskeleton-world contact forces.
\item
Map from exoskeleton-world contact forces and system state to exoskeleton actuator or internal forces.
\item
Map from exoskeleton-world contact forces and system state to exoskeleton acceleration.
\item
Some combination of the above.
\end{enumerate}

\begin{verbatim}
virtual model approach: hopper, compass gait (J. Pratt)
estimate trajectory (jumping) vs. program behavior (trampoline, hopper,
   compass gait)
- J' control + behavior
- Inverse dynamics + behavior
\end{verbatim}

\subsection{Task Specific Control}

Task specific control can involve switching low level control modes, or abstracting
the behavior of the exoskeleton with a hierarchy:
\begin{enumerate}
\item
Task specific control: Generate desired motions and contact forces between
the operator and the exoskeleton, and the exoskeleton and the world.
\item
Sometimes there are intermediate levels of control.
\item
Exoskeleton control: Control the exoskeleton to generate the desired motions and
desired contact forces, with the desired impedance or admittance.
\end{enumerate}

\section{State Estimation}

We have not seen a lot of discussion of state estimation of exoskeletons in
the literature.
We will discuss our approach to state estimation on humanoid robots here.
State estimation to deal with sensor noise,
disturbance estimation, and incomplete or
redundant sensing is a separate process and is as independent as possible
from the control method~\cite{certainty-eq,separation-prin}.
This makes evaluating different control methods much easier.
Disturbance observers for disturbances such as
moving support surfaces, contact or wind forces, and model errors
are also implemented.

For humanoid robot state estimation (for proposed exoskeleton state estimation)
we use extended Kalman Filtering (EKF) to perform state estimation.
Currently, using the full body dynamics (equation~\ref{eq:dynamics2})
and any additional constraint equations for ground contacts (feet on the ground):
\begin{equation}
\mJ_w \ddot{\vq} + \dot{\mJ}_w \dot{\vq} = 0
\end{equation}
is too expensive to produce both a forward prediction and a linearized model
about the current state in the desired 1ms time step.
Therefore we approximate the dynamics by separating the center of mass dynamics
from the joint dynamics and use two separate extended Kalman filters:
a filter for the center of mass dynamics, and a filter for the joint dynamics.
We use an orthogonal (QR) decomposition to project motion into the orthogonal
complement of the contact Jacobian where the ``external'' dynamics (the dynamics
of the center of mass) are separate from the ``internal'' dynamics (the motion
of the joints).

Joint velocities are estimated using actuator position sensors, actuator load
sensors, actuator commands, a single high
quality IMU at the pelvis, and multiple low quality (but cheap) MEMs IMUs
spread throughout the robot or exoskeleton. We also take into account feet and hand
contact forces, which
are measured. We use the full internal dynamics as the process model,
assuming the root dynamics are known. See Chapter 3 of~\cite{Xinjelefu-thesis}.
The internal dynamics are linearized and covariances updated
by a separate process at a 100Hz rate.
The joint positions are predicted by integrating the estimated velocities.

For higher level (overall) state estimation,
we developed a center of mass location and velocity estimator, and its
application in full body inverse dynamics control, fall detection
and fall prevention for humanoid robots and exoskeletons~\cite{}.
The center of mass filter is modeled as a multiple model EKF with contact switching
to handle changes in support: single support, double support, and off the ground.
We use the robot or exoskeleton
joint sensing (kinematics) to create a virtual sensor that measures
center of mass position and velocity relative to a stance foot.
We use Linear
Inverted Pendulum Model (LIPM) dynamics with an offset to predict
the center of mass motion. This offset can be interpreted
as a modelling error on the center of mass position, or an
external force exerted on the center of mass of the robot/exoskeleton,
or a combination of both. The center of mass estimator was
implemented on our Atlas humanoid robot. 
This estimator is especially helpful when compensating
for unplanned slow changing external forces applied at
unknown locations on the robot or exoskeleton, which is quite likely when
operating in tight spaces. It also handles relatively small
dynamic forces well when walking, e.g. dragging a tether
or pushing through a spring loaded door. Thanks to
the estimator, very little tuning is done for our mass model.
During the DARPA
Robotics Challenge Finals
where no safety belay was
allowed, our fall early warning system
successfully saved our robot from
falling on two occasions, and made us the only competitive team
without a fall or need for a human rescue among all teams.

{\bf Safety Code: Fall Prediction:}
The most significant contribution of the external force estimator is that it
can detect when a large external force is being applied that might
push the robot or exoskeleton over.
We compute a ``corrected capture point'' (CCP)~\cite{capture},
which is an offset to the current capture point.
The offset 
takes into account the estimated external force, represented as an offset
to the center of mass.
The corrected capture point getting close to the boundary of the polygon of
support warns the controller that the robot or exoskeleton might fall if the external
force is maintained.
We can also compute the corrected capture point assuming that the
external force follows a known time course plus an estimated constant offset,
or steadily increases or decreases for a fixed time interval
based on an estimated derivative.
We assume the external force is due to the robot's or exoskeleton's
movements, and not
due to external disturbances such as wind, a moving support platform
or external agents pushing on the robot.
The current
behavior is stopped and the robot or exoskeleton can safely be ``frozen'' in place.

A derivation of the corrected capture point starts with LIPM dynamics
augmented with a true center of mass offset and a true external force:
\begin{equation}
\ddot{c} = (c + c_{offset} + f_{ext}*z/mg - cop)*g/z
= (c + \Delta - cop)*g/z
\end{equation}
where $c$ is the location of the center of mass projected on the ground
plane,
$cop$ is the center of pressure
location in that ground plane, and $\Delta$ is the sum of the true center of mass
offset from the modeled center of mass and any external horizontal force.
Our extended Kalman filter estimates $\hat{c}$, $\hat{\dot{c}}$, and
$\hat{\Delta}$,
taking into account the
current center of mass height $z$. We assume a constant center of mass height
in estimating the corrected capture point based on the estimated capture point
as described in~\cite{capture}:
\begin{equation}
\widehat{CCP} = \widehat{CP} + \hat{\Delta} 
= \hat{c} + \hat{\dot{c}}\hat{z}/g + \hat{\Delta}
\end{equation}

For dynamic walking, the corrected capture point goes beyond the
current single foot support polygon during swing phase and is captured by
the touchdown foot. One way to predict a fall is to use the
swing foot time to touchdown and predict if the current
capture point is within the support polygon of possible or desired
footholds. This approach is complicated because it depends
on the controller. Our simpler solution is to use a heuristic
that detects a fall only if the corrected capture point
is outside of the current support
polygon for a continuous period of time. The time threshold was set to
0.6 seconds after extensive testing. As soon as a fall is
predicted, there are several things the humanoid or exoskeleton can do, such
as using angular momentum to maintain balance, or changing the
current or future foot placements.
We have implemented a simple
step recovery controller that works in single support where
the robot or exoskeleton corrects the next foot placement and timing
using a simple heuristic to avoid self collision.
We would only step left if the robot or exoskeleton is falling left, and similarly
for right steps. We avoid crossing the legs in using foot placement
to balance laterally.

\begin{figure}[t]
  \centering
  \hbox{}
      \includegraphics[height=5cm]{figs/door1-5.png}
%      \includegraphics[height=5cm]{figs/door2-1c.png}
      \hbox{}
      \includegraphics[height=5cm]{figs/door1-3.png}
      \hbox{}
      \includegraphics[height=5cm]{figs/door-stuckc2.png}
      \hbox{}
      \caption{Successful sidestepping through the door (left, middle)
        and the failure in the DRC rehearsal (right) in which the protective
        cage (black padding) for the head is against the white door frame.}
      \label{figDoor}
\end{figure}

\begin{figure}[t]
      \centering
      % \includegraphics[width=0.48\textwidth]{figs/door-traces.png}
\subfigure
{\includegraphics[width=0.48\textwidth]{figs/cop_x1.pdf} \label{subfig:ext_cop_x}}
%\subfigure
%{\includegraphics[width=0.48\textwidth]{figs/cop_y.pdf} \label{subfig:ext_cop_y}}
\subfigure
{\includegraphics[width=0.48\textwidth]{figs/ext_f1.pdf} \label{subfig:ext_f}}
\caption{
Atlas was caught on the door frame when sidestepping through it during
the DRC rehearsal.
The walking controller delayed liftoff and remained in double
support when the external force estimator detected a large change
in the estimated external force in the robot's sideways
direction ($F_x$, through the door).
The single support phase is shown by the shaded area, and the black dashed
lines indicates the planned liftoff time.
The estimated CoM is the sum of the model CoM and the estimated CoM offset.
}
\label{figDoorError}
\end{figure}

{\bf Results of Safety Code: Robot caught on door frame:}
In the DRC rehearsal, the robot was caught on
the door frame when sidestepping though (Figure~\ref{figDoor}).
The walking
controller detected an anomaly in the estimated external force in the
sideways direction ($F_x$),
delayed liftoff and remained in double support, and stopped the
current behavior
to allow for manual recovery (Figure~\ref{figDoorError}).

{\bf Results of Safety Code: Manipulation Error:}
For the manipulation controller, the robot is always assumed
to be in double support, and the support polygon
is computed by finding the convex hull of the foot corner
points (light green in Figure~\ref{figDrillCOP}),
computed using forward kinematics.
To prevent the robot from falling during
manipulation, we require the corrected capture point to be within a
subset of the support polygon called the safe region, 
(dark green in Figure~\ref{figDrillCOP}),
When the corrected capture point escapes the safe region,
a freeze signal is sent to the manipulation controller, and it
clears all currently executing joint trajectories and freezes the robot
at the current pose, with the balance controller still running.

During our second
run in the Finals, our right electric forearm mechanically failed
when the cutting motion was initiated for the drill task. The
uncontrolled forearm wedged the drill into the wall and
pushed the robot backwards.
The controller stopped the behavior (a freeze),
and saved the robot from falling (Figure~\ref{figDrillCOP}).
The operator was then able to
recover from an otherwise catastrophic scenario.

The time plot in Figure~\ref{figDrillCOP} shows candidate fall predictors
during this event. We can eliminate some candidate fall predictors
easily. The center of mass (CoM) (and a ``corrected'' CoM (not shown))
usually provide a fall warning too late, because the CoM velocity is not
included. The capture point (CP) does not include information about
external forces. The center of pressure (CoP) is 
noisy and gives too many false alarms. It can warn of 
foot tipping, but it is less reliable about warning about robot falling,
which is not the same thing as foot tipping in a force controlled robot
or if there are non-foot contacts and external
forces. In this plot, we see that the CoP moves away from the safe region
during recovery, predicting that the robot is falling again, while the
corrected capture point (CCP) moves towards the interior of the safe region.

\begin{figure}[t]
      \centering
      \includegraphics[height=30mm]{figs/near-fall2c.png}
      \includegraphics[height=30mm]{figs/drill-cop1.png}
      \includegraphics[height=30mm]{figs/drill-cop2.png}
      \includegraphics[height=30mm]{figs/drill-cop3.png}\\
\includegraphics[width=0.48\textwidth]{figs/cp_time_xes.pdf}
      \caption{Top Left: Robot posture after 
error detection.
Top Right: Black trace: The corrected capture point (CCP)
up to the error detection,
Red trace: The CCP during the ``frozen'' period, and Blue trace: The CCP moves
back to the center of the polygon of support during manual recovery.
Bottom: Plots of candidate fall predictors in the fore/aft direction
during this event. The black vertical dashed lines mark the freeze time and
the start of manual recovery.}
      \label{figDrillCOP}
\end{figure}

Unscented and particle filters could be used instead of extended
Kalman filtering. It may well be the case that unscented filtering
outperforms extended Kalman filtering.

\subsection{Current state estimation approaches in exoskeletons}

We see that Sensitivity Amplification Control uses acceleration as an input.
Estimating acceleration using double differentiation with low pass filtering
currently works well on real exoskeletons.
However, impacts, shock waves, and the fact that neither
the operator's body parts or the exoskeletons parts are rigid bodies and the
joints are not well defined suggest this approach can be improved with actual
acceleration measurements.
It is now possible to distribute MEMs IMUs throughout the exoskeleton to
improve both velocity and 
acceleration estimation~\cite{Xinjilefu-thesis}, which should improve
Sensitivity Amplification Control.

Disturbance observers~\cite{IEEE06197032}.

\section{Robustness to parametric modeling error and unmodelled dynamics}

We need to be robust to parameter modeling errors such as the wrong mass,
center of mass location, joint location,
or moment of inertia for an exoskeleton part, variations in the operator
parameters, and variations in attachments to the exoskeleton and payload.
Examples of unmodeled dynamics (non-parametric modeling error) include:
backlash, joint play, structural deformation, flexible wires and hoses,
actuator dynamics, processing delay,
elastic operator tissue and straps, and 
loose or slack operator tissue and straps.

There are two questions to focus on:

\subsection{How robust are these control schemes to parametric and non-parametric
modeling error?}

This question needs to be addressed using simulation, and is deferred to a future
white paper [robust.pdf].

\subsection{How can we make control more robust?}

One way to understand control systems is to separate 1) what happens when there
are no errors and feedback control is not active, and 2) what happens in response
to errors (feedback control). 
What happens when there are no errors in model-based control is 
feedforward control, which does not have stability issues (except for some ignorable
technical issues). If your model is good, you get good performance. If your
model is bad, you get larger errors and have to rely on feedback control.
You may crash the exoskeleton, or fall down, but you will not oscillate
(except in some contrived examples) and errors do not grow exponentially in
response to feedforward control errors.
So feedforward control is technically robust,  
and we don't have to worry about it blowing up (except for chaotic systems).
We do have to worry about performance.
We have
to worry about how to get good models, and what to do about stuff that varies:
contacts, operator body, operator behavior, payloads, attachments, etc.

On the other hand, feedback control can lead to steady state or growing
oscillation, which we colloquially refer to as being unstable or instability.
Since walking and running are also oscillations which we refer to as stable
behaviors, the technical meaning of the word ``stable'' is more complex than
just ``it keeps moving'' or ``it doesn't do what the operator wants''.
In any event, we don't want oscillations.

The best way to avoid oscillations is to manually design a conservative 
independent joint feedback controller.
This way it can be tested independently of any
feedforward control.
Unfortunately, inverse dynamics and online optimization-based control mix
feedforward and feedback control so we cannot use the recommended, well established,
and safe approach of manual conservative independent joint feedback control design. 

What to do about this to achieve robust online optimalization-based control is
currently a research issue. In actual implementations, skilled engineers manually
tune optimization weights and the various constraints that are active to
make this type of control work reliably. The fact that this has been done on many actual
humanoid robots in many situations is comforting. The fact that none of these
implementations have moved with the speed and agility of a top percentile
human athlete is disconcerting.

We can ``verify'' designs using simulation, but making accurate simulations of
the effects of contact and unmodelled dynamics is also a current research issue.
There is no getting around the fact that our operators will be like the test
pilots of early planes. The exoskeletons may crash, flail wildly, or oscillate.
We need to plan for operator safety from day 1 of operation, not try to retrofit
it later.

If the robustness of online optimization is not adequate, an alternative is
combining feedforward and feedback control into one function and using gradient
descent in simulation to improve the control robustness.
One technique to do this is multiple-model design~\cite{acc12}.

Note that adaptive or learning
control does not promise to improve the kind of robustness exoskeltons need. 
These approaches promise
to improve performance, and try to track (slowly) changes in the operator, exoskeleton,
or contacts to maintain performance. If something changes quickly, we need robust
control design.

\section{Discussion}

Discussion to be written.

\section{Conclusions and Recommendations}

Conclusions and Recommendations to be written.

1) We recommend a particular control 
overall architecture in Section~\ref{sec:architecture}.
We do not expect this to be controversial.

2) We recommend actuation that can be treated as force or torque sources.
This is a potential problem for revolute electric actuation, as it
is difficult to get necessary performance at low gear ratios (20-50)
and fit the necessary torque sensing.

3) We recommend the use of dynamic models of the exoskeleton, as has been done
for the last decade starting with the BLEEX exoskeleton.
We do not expect this to be controversial.

4) We recommend using online optimization as part of the Low Level Controller
in the form of quadratic programming. Online optimization
was tested by the top biped robot
teams in the DARPA Robotics Challenge, and worked well.
A possible objection to online optimization
is that it requires more substantial computing
resources than current exoskeleton control methods. We feel the feasibility
of this approach has been demonstrated and is easily achievable. Perceptual
computing costs will dwarf computing costs for control, 
so the computation cost is a non-issue.

5) We recommend applying as many sensors as possible, and asking the performers
to make it easy to add more by making the sensor network available in the design.
This maximizes the probability of success
with respect to control architectures and algorithms by enabling multiple control
approaches to be implemented, refined, and support each other.
In particular, we would like to see force sensing between the operator and the
exoskeleton, including at the feet, as much force sensing between the exoskeleton 
and the world as possible, but minimally full six-axis force/torque sensing at
the exoskeleton feet (where they touch the ground). We would like to see multiple MEMs
IMUs (measuring linear acceleration and angular velocity) installed across 
the exoskeleton and at least one high quality fiber optic gyro IMU. 
We would like to see high quality direct velocity sensing
such as high count (100,000 counts/revolution) encoders and/or 
analog rotary or linear tachometers on actuators and joints. 
We would like to see actuator force or torque sensors
(load cells or equivalents) with the measurement on the link side (rather than
the actuator side) of any transmission. Electric current in motors and oil
pressure in hydraulic pistons can also be used for actuator force estimation,
but because these measurements are on the actuator side before the transmission
and in the case of hydraulics before the oil seals on the piston, these measurements
are greatly contaminated by friction. On the Atlas humanoid we typically saw 10Nm
joint torque estimation errors for a system that estimated actuator output using
oil pressure on each side of the piston head.
A possible objection to this is additional cost. We feel it is a false
economy to skimp on sensing. Leaving practical sensing out greatly increases
the risk of poor performance.

6) We recommend a ``symbiotic'' control system design should be used as a backup,
in case more aggressive design philosophies such as ``invisible'' and ``natural''
control system designs are not achievable.,
The ``symbiotic'' control system design
expects the operator to adapt to the exoskeleton and its control,
and has the control customized for the operator.

7) We recommend making use of virtual model control specialize
for the various tasks. This can greatly increase operator/exoskeleton system
performance over an exoskeleton that just carries a load and is otherwise
``invisible''.

\bibliographystyle{plain}
\bibliography{exo}

\end{document}




sensitivity to
 modeling error
 sensor error
 unmodeled dynamics

underactuated control problem
 - not fully actuated sagittal only.
 - how necessary is lateral actuation
 - what is the penalty
  weight
  drag of actuator

how handle failure and damage after Oct 1

what about a full model of the system

Oct 5-9
